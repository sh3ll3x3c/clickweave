
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async ping() : Promise<string> {
    return await TAURI_INVOKE("ping");
},
async pickWorkflowFile() : Promise<Result<string | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("pick_workflow_file") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async pickSaveFile() : Promise<Result<string | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("pick_save_file") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async openProject(path: string) : Promise<Result<ProjectData, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_project", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async saveProject(path: string, workflow: Workflow) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_project", { path, workflow }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async validate(workflow: Workflow) : Promise<ValidationResult> {
    return await TAURI_INVOKE("validate", { workflow });
},
async nodeTypeDefaults() : Promise<NodeTypeInfo[]> {
    return await TAURI_INVOKE("node_type_defaults");
},
async planWorkflow(request: PlanRequest) : Promise<Result<PlanResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("plan_workflow", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async patchWorkflow(request: PatchRequest) : Promise<Result<WorkflowPatch, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("patch_workflow", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async assistantChat(request: AssistantChatRequest) : Promise<Result<AssistantChatResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("assistant_chat", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async cancelAssistantChat() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("cancel_assistant_chat") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async saveConversation(path: string, conversation: ConversationSession) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_conversation", { path, conversation }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async loadConversation(path: string) : Promise<Result<ConversationSession | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("load_conversation", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async runWorkflow(request: RunRequest) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("run_workflow", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async stopWorkflow() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stop_workflow") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async supervisionRespond(action: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("supervision_respond", { action }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async listRuns(query: RunsQuery) : Promise<Result<NodeRun[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_runs", { query }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async loadRunEvents(query: RunEventsQuery) : Promise<Result<TraceEvent[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("load_run_events", { query }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async readArtifactBase64(path: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("read_artifact_base64", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async importAsset(projectPath: string) : Promise<Result<ImportedAsset | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("import_asset", { projectPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

export type AiStepParams = { prompt: string; button_text: string | null; template_image: string | null; max_tool_calls: number | null; allowed_tools: string[] | null; timeout_ms?: number | null }
export type AppDebugKitParams = { operation_name: string; parameters: JsonValue }
export type Artifact = { artifact_id: string; kind: ArtifactKind; path: string; metadata: JsonValue; overlays: JsonValue[] }
export type ArtifactKind = "Screenshot" | "Ocr" | "TemplateMatch" | "Log" | "Other"
export type AssistantChatRequest = { workflow: Workflow; user_message: string; history: ChatEntry[]; summary: string | null; summary_cutoff: number; run_context: RunContext | null; planner: EndpointConfig; allow_ai_transforms: boolean; allow_agent_steps: boolean; mcp_command: string; max_repair_attempts: number }
export type AssistantChatResponse = { assistant_message: string; patch: WorkflowPatch | null; new_summary: string | null; summary_cutoff: number; warnings: string[] }
/**
 * A single entry in the assistant conversation.
 */
export type ChatEntry = { role: ChatRole; content: string; timestamp: number; patch_summary?: PatchSummary | null; run_context?: RunContext | null }
export type ChatRole = "user" | "assistant"
export type Check = { name: string; check_type: CheckType; params: JsonValue; on_fail: OnCheckFail }
export type CheckType = "TextPresent" | "TextAbsent" | "TemplateFound" | "WindowTitleMatches"
export type ClickParams = { target: string | null; x: number | null; y: number | null; button: MouseButton; click_count: number }
export type Condition = { left: ValueRef; operator: Operator; right: ValueRef }
/**
 * Persistent conversation session for a workflow.
 */
export type ConversationSession = { messages: ChatEntry[]; summary?: string | null; summary_cutoff?: number }
export type Edge = { from: string; to: string; 
/**
 * Which output port this edge connects from. None for regular single-output edges.
 */
output: EdgeOutput | null }
export type EdgeOutput = { type: "IfTrue" } | { type: "IfFalse" } | { type: "SwitchCase"; name: string } | { type: "SwitchDefault" } | 
/**
 * Edge from Loop node into the loop body.
 */
{ type: "LoopBody" } | 
/**
 * Edge from Loop node when exit condition is met (or max iterations hit).
 */
{ type: "LoopDone" }
export type EndLoopParams = { 
/**
 * Explicit pairing with the Loop node. Stored as UUID rather than inferred
 * from graph structure for safety and simpler validation.
 * When EndLoop is reached during execution, the walker jumps directly to
 * this Loop node, which then re-evaluates its exit condition.
 */
loop_id: string }
export type EndpointConfig = { base_url: string; model: string; api_key: string | null }
export type ExecutionMode = "Test" | "Run"
export type FindImageParams = { template_image: string | null; threshold: number; max_results: number }
export type FindTextParams = { search_text: string; match_mode: MatchMode; scope: string | null; select_result: string | null }
export type FocusMethod = "WindowId" | "AppName" | "Pid"
export type FocusWindowParams = { method: FocusMethod; value: string | null; bring_to_front: boolean }
export type IfParams = { condition: Condition }
export type ImportedAsset = { relative_path: string; absolute_path: string }
export type JsonValue = null | boolean | number | string | JsonValue[] | Partial<{ [key in string]: JsonValue }>
export type ListWindowsParams = { app_name: string | null }
export type LiteralValue = { type: "String"; value: string } | { type: "Number"; value: number } | { type: "Bool"; value: boolean }
export type LoopParams = { 
/**
 * Loop exits when this condition becomes true.
 * NOTE: Uses do-while semantics â€” the exit condition is NOT checked on the
 * first iteration (iteration 0). The loop body always runs at least once.
 * This is intentional for UI automation where the common pattern is
 * "try action, check if it worked, loop if not."
 */
exit_condition: Condition; 
/**
 * Safety cap to prevent infinite loops. Default: 100.
 * If max_iterations is hit, the loop exits with a warning trace event
 * (loop_exited with reason "max_iterations"), which likely indicates
 * something unexpected happened.
 */
max_iterations: number }
export type MatchMode = "Contains" | "Exact"
export type McpToolCallParams = { tool_name: string; arguments: JsonValue }
export type MouseButton = "Left" | "Right" | "Center"
export type Node = { id: string; node_type: NodeType; position: Position; name: string; enabled: boolean; timeout_ms: number | null; settle_ms: number | null; retries: number; trace_level: TraceLevel; expected_outcome: string | null; checks: Check[] }
export type NodeResult = { node_name: string; status: string; error?: string | null }
export type NodeRun = { run_id: string; node_id: string; node_name?: string; execution_dir?: string; started_at: number; ended_at: number | null; status: RunStatus; trace_level: TraceLevel; events: TraceEvent[]; artifacts: Artifact[]; observed_summary: string | null }
export type NodeType = ({ type: "AiStep" } & AiStepParams) | ({ type: "TakeScreenshot" } & TakeScreenshotParams) | ({ type: "FindText" } & FindTextParams) | ({ type: "FindImage" } & FindImageParams) | ({ type: "Click" } & ClickParams) | ({ type: "TypeText" } & TypeTextParams) | ({ type: "PressKey" } & PressKeyParams) | ({ type: "Scroll" } & ScrollParams) | ({ type: "ListWindows" } & ListWindowsParams) | ({ type: "FocusWindow" } & FocusWindowParams) | ({ type: "McpToolCall" } & McpToolCallParams) | ({ type: "AppDebugKitOp" } & AppDebugKitParams) | ({ type: "If" } & IfParams) | ({ type: "Switch" } & SwitchParams) | ({ type: "Loop" } & LoopParams) | ({ type: "EndLoop" } & EndLoopParams)
export type NodeTypeInfo = { name: string; category: string; icon: string; node_type: NodeType }
export type OnCheckFail = "FailNode" | "WarnOnly"
export type Operator = "Equals" | "NotEquals" | "GreaterThan" | "LessThan" | "GreaterThanOrEqual" | "LessThanOrEqual" | "Contains" | "NotContains" | "IsEmpty" | "IsNotEmpty"
export type PatchRequest = { workflow: Workflow; user_prompt: string; planner: EndpointConfig; allow_ai_transforms: boolean; allow_agent_steps: boolean; mcp_command: string }
/**
 * Compact summary of what a patch did (for conversation context, not the full patch).
 */
export type PatchSummary = { added: number; removed: number; updated: number; added_names?: string[]; removed_names?: string[]; updated_names?: string[]; description?: string | null }
export type PlanRequest = { intent: string; planner: EndpointConfig; allow_ai_transforms: boolean; allow_agent_steps: boolean; mcp_command: string }
export type PlanResponse = { workflow: Workflow; warnings: string[] }
export type Position = { x: number; y: number }
export type PressKeyParams = { key: string; modifiers: string[] }
export type ProjectData = { path: string; workflow: Workflow }
/**
 * Execution results available at the time of a message.
 */
export type RunContext = { execution_dir: string; node_results: NodeResult[] }
export type RunEventsQuery = { project_path: string | null; workflow_id: string; workflow_name: string; node_name: string; execution_dir: string | null; run_id: string }
export type RunRequest = { workflow: Workflow; project_path: string | null; agent: EndpointConfig; vlm: EndpointConfig | null; planner: EndpointConfig | null; mcp_command: string; execution_mode: ExecutionMode }
export type RunStatus = "Ok" | "Failed" | "Stopped"
export type RunsQuery = { project_path: string | null; workflow_id: string; workflow_name: string; node_name: string }
export type ScreenshotMode = "Screen" | "Window" | "Region"
export type ScrollParams = { delta_y: number; x: number | null; y: number | null }
export type SwitchCase = { 
/**
 * Label shown on the edge, e.g. "Has error".
 */
name: string; condition: Condition }
export type SwitchParams = { 
/**
 * Evaluated in order; first matching case wins.
 */
cases: SwitchCase[] }
export type TakeScreenshotParams = { mode: ScreenshotMode; target: string | null; include_ocr: boolean }
export type TraceEvent = { timestamp: number; event_type: string; payload: JsonValue }
export type TraceLevel = "Off" | "Minimal" | "Full"
export type TypeTextParams = { text: string }
export type ValidationResult = { valid: boolean; errors: string[] }
export type ValueRef = { type: "Variable"; name: string } | { type: "Literal"; value: LiteralValue }
export type Workflow = { id: string; name: string; nodes: Node[]; edges: Edge[] }
export type WorkflowPatch = { added_nodes: Node[]; removed_node_ids: string[]; updated_nodes: Node[]; added_edges: Edge[]; removed_edges: Edge[]; warnings: string[] }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
