
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async ping() : Promise<string> {
    return await TAURI_INVOKE("ping");
},
async pickProjectFolder() : Promise<Result<string | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("pick_project_folder") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async openProject(path: string) : Promise<Result<ProjectData, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_project", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async saveProject(path: string, workflow: Workflow) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_project", { path, workflow }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async validate(workflow: Workflow) : Promise<ValidationResult> {
    return await TAURI_INVOKE("validate", { workflow });
},
async nodeTypeDefaults() : Promise<NodeTypeInfo[]> {
    return await TAURI_INVOKE("node_type_defaults");
},
async runWorkflow(request: RunRequest) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("run_workflow", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async stopWorkflow() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stop_workflow") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

export type AiStepParams = { prompt: string; button_text: string | null; template_image: string | null; max_tool_calls: number | null; allowed_tools: string[] | null }
export type AppDebugKitParams = { operation_name: string; parameters: JsonValue }
export type Check = { name: string; check_type: CheckType; params: JsonValue; on_fail: OnCheckFail }
export type CheckType = "TextPresent" | "TextAbsent" | "TemplateFound" | "WindowTitleMatches"
export type ClickParams = { target: string | null; button: MouseButton; click_count: number }
export type Edge = { from: string; to: string }
export type FindImageParams = { template_image: string | null; threshold: number; max_results: number }
export type FindTextParams = { search_text: string; match_mode: MatchMode; scope: string | null; select_result: string | null }
export type FocusMethod = "WindowId" | "AppName" | "TitlePattern"
export type FocusWindowParams = { method: FocusMethod; value: string | null; bring_to_front: boolean }
export type JsonValue = null | boolean | number | string | JsonValue[] | Partial<{ [key in string]: JsonValue }>
export type ListWindowsParams = { app_name: string | null; title_pattern: string | null }
export type MatchMode = "Contains" | "Exact"
export type MouseButton = "Left" | "Right" | "Center"
export type Node = { id: string; node_type: NodeType; position: Position; name: string; enabled: boolean; timeout_ms: number | null; retries: number; trace_level: TraceLevel; expected_outcome: string | null; checks: Check[] }
export type NodeType = ({ type: "AiStep" } & AiStepParams) | ({ type: "TakeScreenshot" } & TakeScreenshotParams) | ({ type: "FindText" } & FindTextParams) | ({ type: "FindImage" } & FindImageParams) | ({ type: "Click" } & ClickParams) | ({ type: "TypeText" } & TypeTextParams) | ({ type: "Scroll" } & ScrollParams) | ({ type: "ListWindows" } & ListWindowsParams) | ({ type: "FocusWindow" } & FocusWindowParams) | ({ type: "AppDebugKitOp" } & AppDebugKitParams)
export type NodeTypeInfo = { name: string; category: string; icon: string; node_type: NodeType }
export type OnCheckFail = "FailNode" | "WarnOnly"
export type Position = { x: number; y: number }
export type ProjectData = { path: string; workflow: Workflow }
export type RunRequest = { workflow: Workflow; project_path: string | null; llm_base_url: string; llm_model: string; llm_api_key: string | null; mcp_command: string }
export type ScreenshotMode = "Screen" | "Window" | "Region"
export type ScrollParams = { delta_y: number; x: number | null; y: number | null }
export type TakeScreenshotParams = { mode: ScreenshotMode; target: string | null; include_ocr: boolean }
export type TraceLevel = "Off" | "Minimal" | "Full"
export type TypeTextParams = { text: string; press_enter: boolean }
export type ValidationResult = { valid: boolean; errors: string[] }
export type Workflow = { id: string; name: string; nodes: Node[]; edges: Edge[] }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
